#version 460

// an atom needs to have enough electrons to be able to form π and double-π bonds
#define min_π_type (3)
#define min_ππ_type (4)
#define λ28 (1.69)
#define NUM_VERTICES (256)

layout(local_size_x = 64) in;
layout(local_size_y = 1) in;
layout(local_size_z = 1) in;

layout(set = 0, binding = 0) uniform Config{
    float dt;
    float worldWidth;
    float worldHeight;
} ubo;

// TODO would it make sense to just use a single buffer for all of these?

// The fourth value of "posit" is actually the type encoded as an unsigned integer
layout(set = 1, binding = 0) buffer Position{
    vec4 array[];
} posit;

layout(set = 1, binding = 1) buffer Velocity{
    vec4 array[];
} veloc;

layout(set = 1, binding = 2) buffer Acceleration{
    vec4 array[];
} accel;

layout(set = 1, binding = 3) buffer Acceleration_{
    vec4 array[];
} accel_;

// TODO presumably we can come up with a way to automatically compute this from C-C values rather than writing down the full n^2/2 values
float p_bo1_lut(uint i, uint j) {
    return
        i == 1 && j == 1 ? -0.016 :
        i == 1 && j == 6 ? -0.013 :
        i == 6 && j == 1 ? -0.013 :
        i == 6 && j == 6 ? -0.097 :
        0;
}

float p_bo2_lut(uint i, uint j) {
    return
        i == 1 && j == 1 ? 5.98 :
        i == 1 && j == 6 ? 7.65 :
        i == 6 && j == 1 ? 7.65 :
        i == 6 && j == 6 ? 6.38 :
        0;
}

float p_bo3_lut(uint i, uint j) {
    return i == 6 && j == 6 ? -0.26 : 0;
}

float p_bo4_lut(uint i, uint j) {
    return i == 6 && j == 6 ? 9.37 : 0;
}

float p_bo5_lut(uint i, uint j) {
    return i == 6 && j == 6 ? -0.391 : 0;
}

float p_bo6_lut(uint i, uint j) {
    return i == 6 && j == 6 ? 16.87 : 0;
}

float de_lut(uint i, uint j) {
    return
        i == 1 && j == 1 ? 168.4 :
        i == 1 && j == 6 ? 183.8 :
        i == 6 && j == 1 ? 183.8 :
        i == 6 && j == 6 ? 145.2 :
        0;
}

float ε_lut(uint i) {
    return i == 1 ? 0.0194 : i == 6 ? 0.0862 : 0;
}

float rvdw_lut(uint i) {
    return i == 1 ? 3.649 : i == 6 ? 3.912 : 0;
}

float ɑ_lut(uint i) {
    return i == 1 ? 10.06 : i == 6 ? 10.71 : 0;
}

float ɣw_lut(uint i) {
    return i == 1 ? 5.36 : i == 6 ? 1.41 : 0;
}

float mass(uint i) {
    return i == 1 ? 1.007825 : i == 6 ? 12 : 0;
}

float charge(uint i) {
    return i == 1 ? 0 : i == 6 ? 0 : 0;
}

float lj_σ(uint i) {
    return i == 1 ? 0.5523570 : i == 6 ? 1.3541700 : 0;
}

float lj_ε(uint i) {
    return i == 1 ? 4.4778900 : i == 6 ? 6.3695300 : 0;
}

float rσ_lut(uint i) {
    return i == 1 ? 0.656 : i == 6 ? 1.399 : 0;
}

float rπ_lut(uint i) {
    return i == 6 ? 1.266 : 1;
}

float rπππ_lut(uint i) {
    return i == 6 ? 1.236 : 1;
}

float valence(uint i) {
    return i == 1 ? 1 : i == 6 ? 4 : 0;
}

float lj_shield_power = 3;
float lj_shield_start = 1.2;

float fbo′(float r, float pa, float pb, float ro) {
    return exp(pa * pow((r / ro), pb));
}

// TODO for peace of mind just double check that this is the correct derivative of fbo′
float fdbo′(float r, float pa, float pb, float ro) {
    return pa * pb * pow((r / ro), pb) * fbo′(r, pa, pb, ro);
}

void main() {
    const uint gid = gl_GlobalInvocationID.x;
    if (gid >= NUM_VERTICES) return;

    const vec4 iprops = posit.array[gid];
    const vec2 ipos = iprops.xy;
    const uint itype = floatBitsToInt(iprops.w);

    // mass in Daltons
    const float m = mass(itype);

    vec2 force = vec2(0.);

    float _Δ′ = -valence(itype);
    vec2 dΔ′ = vec2(0.);

    for (uint j = 0; j < NUM_VERTICES; j++) {
        if (j == gid) continue;

        const vec4 jprops = posit.array[j];
        const vec2 jpos = jprops.xy;
        const uint jtype = floatBitsToInt(jprops.w);

        // set minimum r for numerical stability in edge cases that shouldn't
        // typically occur
        const float r = max(.2, distance(ipos, jpos));

        const float p_bo1 = p_bo1_lut(itype, jtype);
        const float p_bo2 = p_bo2_lut(itype, jtype);
        const float p_bo3 = p_bo3_lut(itype, jtype);
        const float p_bo4 = p_bo4_lut(itype, jtype);
        const float p_bo5 = p_bo5_lut(itype, jtype);
        const float p_bo6 = p_bo6_lut(itype, jtype);

        const float rσ = (rσ_lut(itype) + rσ_lut(jtype)) / 2.;
        const float rπ = (rπ_lut(itype) + rπ_lut(jtype)) / 2.;
        // XXX JB should this use rπ_lut twice?
        const float rππ = (rπ_lut(itype) + rπ_lut(jtype)) / 2.;

        const float bo′σ = fbo′(r, p_bo1, p_bo2, rσ);
        const float bo′π = itype >= min_π_type && jtype >= min_π_type ? fbo′(r, p_bo3, p_bo4, rπ) : 0;
        // XXX JB should this be min_ππ_type twice?
        const float bo′ππ = itype >= min_ππ_type && jtype >= min_π_type ? fbo′(r, p_bo5, p_bo6, rππ) : 0;
        const float bo′ = bo′σ + bo′π + bo′ππ;

        // TODO simplify?
        const vec2 dr = vec2(ipos.x - jpos.x, ipos.y - jpos.y) / r;

        const float dbo′σ = fdbo′(r, p_bo1, p_bo2, rσ);
        const float dbo′π = itype >= min_π_type && jtype >= min_π_type ? fdbo′(r, p_bo3, p_bo4, rπ) : 0;
        // XXX JB should this be min_ππ_type twice?
        const float dbo′ππ = itype >= min_π_type && jtype >= min_π_type ? fdbo′(r, p_bo5, p_bo6, rππ) : 0;
        const vec2 dbo′ = ((dbo′σ + dbo′π + dbo′ππ) / r) * dr;

        _Δ′ += bo′;
        dΔ′ += dbo′;
    }

    for (uint j = 0; j < NUM_VERTICES; j++) {
        if (j == gid) continue;

        const vec4 jprops = posit.array[j];
        const vec2 jpos = jprops.xy;
        const uint jtype = floatBitsToInt(jprops.w);

        // set minimum r for numerical stability in edge cases that shouldn't
        // typically occur
        const float r = max(.2, distance(ipos, jpos));

        const float p_bo1 = p_bo1_lut(itype, jtype);
        const float p_bo2 = p_bo2_lut(itype, jtype);
        const float p_bo3 = p_bo3_lut(itype, jtype);
        const float p_bo4 = p_bo4_lut(itype, jtype);
        const float p_bo5 = p_bo5_lut(itype, jtype);
        const float p_bo6 = p_bo6_lut(itype, jtype);

        const float rσ = (rσ_lut(itype) + rσ_lut(jtype)) / 2.;
        const float rπ = (rπ_lut(itype) + rπ_lut(jtype)) / 2.;
        // XXX JB should this use rπ_lut twice?
        const float rππ = (rπ_lut(itype) + rπ_lut(jtype)) / 2.;

        const float bo′σ = fbo′(r, p_bo1, p_bo2, rσ);
        const float bo′π = itype >= min_π_type && jtype >= min_π_type ? fbo′(r, p_bo3, p_bo4, rπ) : 0;
        // XXX JB should this be min_ππ_type twice?
        const float bo′ππ = itype >= min_ππ_type && jtype >= min_π_type ? fbo′(r, p_bo5, p_bo6, rππ) : 0;
        const float bo′ = bo′σ + bo′π + bo′ππ;

        // TODO simplify?
        const vec2 dr = vec2(ipos.x - jpos.x, ipos.y - jpos.y) / r;

        const float dbo′σ = fdbo′(r, p_bo1, p_bo2, rσ);
        const float dbo′π = itype >= min_π_type && jtype >= min_π_type ? fdbo′(r, p_bo3, p_bo4, rπ) : 0;
        // XXX JB should this be min_ππ_type twice?
        const float dbo′ππ = itype >= min_π_type && jtype >= min_π_type ? fdbo′(r, p_bo5, p_bo6, rππ) : 0;
        const vec2 dbo′ = ((dbo′σ + dbo′π + dbo′ππ) / r) * dr;

        // converting kcal/mole into eV
        const float de = de_lut(itype, jtype) * .0434;

        // potential valley gets closer to nucleus as bond order increases
        // unchanged at BO = 0, reduced by ~50% at BO = 1, and reduced by ~60% at BO = 3
        const float σ0 = (lj_σ(itype) + lj_σ(jtype)) / 2.;
        const float σ = σ0 * (.6 * pow(.17, bo′) + .4);
        const float ε0 = sqrt(lj_ε(itype) * lj_ε(jtype));
        const float ε = ε0 + de * bo′;

        const vec2 dσ = σ0 * .6 * (-.177196) * pow(.17, bo′) * dbo′;
        const vec2 dε = de * dbo′;

        // XXX JB not sure the sign is right, but it seems to work
        const vec2 force′ = normalize(jpos - ipos) *
            (-((4 * pow(σ, 5) / pow(r, 13)) *
               (r * σ * (pow(r, 6) - pow(σ, 6)) * dε + 6 * ε * (pow(r, 6) - 2 * pow(σ, 6)) * (r * dσ - σ))));

        // Unit conversion:
        // We have eV/Angstrom, we want Dalton * Angstrom * fs^-2
        force += .00964853322 * force′;
    }

    accel.array[gid].xy = force / m;
}
